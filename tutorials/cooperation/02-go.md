---
title: "2. Go"
date: 2025-10-23
---

Now we turn to action! In this section, we will implement the `go` procedure that will handle the two main stages of our model: the Game Play Stage and the Evolutionary Stage.

```ruby
to go
    if (all? players [strategy = "ALLC"] or all? players [strategy = "ALLD"]) [stop]
    game-play-stage
    evolutionary-stage
    recolor-players
    tick
end
```

## Game Play Stage

In the Game Play Stage, each agent will interact with its 8 neighbors and accumulate payoffs based on their strategies. We will define a procedure called `game-play-stage` to handle this.

```ruby
to game-play-stage
    ask players [
        set payoff 0  ; reset payoff before interactions
        let n_C count neighbors with [strategy = "ALLC"]
        let n_D 8 - n_C
        ifelse (strategy = "ALLC") [
            set payoff (n_C * (benefit - cost)) + (n_D * (- cost))
        ] [
            set payoff (n_C * benefit) + (n_D * 0)
        ]
    ]
end
```

## Evolutionary Stage

In the Evolutionary Stage, agents will update their strategies based on the payoffs received during the Game Play Stage. An agent may adopt the strategy of a neighbor with a higher payoff. We will define a procedure called `evolutionary-stage` to handle this.

```ruby
to evolutionary-stage
    ask players [
        let best-neighbor max-one-of neighbors [payoff]
        if (best-neighbor != nobody and [payoff] of best-neighbor > payoff) [
            set strategy [strategy] of best-neighbor
        ]
    ]
end
```

With these procedures in place, our model is now capable of simulating the dynamics of cooperation and defection among agents in a lattice structure. Each tick of the simulation will represent one round of interactions and strategy updates.

```{admonition} Complete Code
:class: tip
The complete code for the `go` procedure along with the `game-play-stage` and `evolutionary-stage` procedures is available [through this link](codes/B-Go.nlogox).
```
